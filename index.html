<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PhD Candidate | Oxford Robotics Institute</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --text-color: #e2e8f0;
            --accent-cyan: #06b6d4;
            --accent-pink: #ec4899;
            --glass: rgba(15, 23, 42, 0.85);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Roboto Mono', 'Courier New', monospace;
            overflow: hidden; /* Canvas covers everything */
            height: 100vh;
            width: 100vw;
        }

        /* The Canvas is the background and the interaction layer */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* Let clicks pass through to canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
        }

        header {
            pointer-events: auto;
        }

        h1 {
            font-size: 2.5rem;
            text-transform: uppercase;
            letter-spacing: -2px;
        }

        h2 {
            color: var(--accent-cyan);
            font-size: 1.2rem;
            margin-top: 0.5rem;
        }

        .subtitle {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-top: 0.2rem;
        }

        /* The Info Card that appears when a node is clicked */
        #info-card {
            position: absolute;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%) translateX(120%); /* Hidden by default */
            width: 400px;
            background: var(--glass);
            border: 1px solid var(--accent-cyan);
            padding: 2rem;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            pointer-events: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        #info-card.active {
            transform: translateY(-50%) translateX(0);
        }

        #info-card h3 {
            color: var(--accent-pink);
            margin-bottom: 1rem;
            border-bottom: 1px solid #334155;
            padding-bottom: 0.5rem;
        }

        #info-card p {
            font-size: 0.9rem;
            line-height: 1.6;
            margin-bottom: 1rem;
            color: #cbd5e1;
        }

        #info-card ul {
            list-style-type: square;
            margin-left: 1.5rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        #info-card .math {
            background: rgba(255,255,255,0.05);
            padding: 0.5rem;
            border-radius: 4px;
            font-style: italic;
            text-align: center;
            margin: 1rem 0;
            font-family: serif;
        }

        #controls {
            font-size: 0.8rem;
            color: #64748b;
            pointer-events: auto;
        }
        
        .key {
            color: var(--accent-cyan);
            font-weight: bold;
        }
    </style>
</head>
<body>

    <canvas id="simCanvas"></canvas>

    <div id="ui-layer">
        <header>
            <h1>Your Name</h1>
            <h2>Oxford Robotics Institute</h2>
            <div class="subtitle">PhD Candidate | Fundamental AI & Robot Learning</div>
        </header>

        <div id="info-card">
            <h3 id="card-title">Title</h3>
            <div id="card-content">Content goes here.</div>
        </div>

        <div id="controls">
            <p>> INTERACTION MODE: <span class="key">SPRING_DAMPING</span></p>
            <p>> STATUS: <span class="key">AWAITING_MANIPULATION</span></p>
            <p>> DRAG NODES TO OBSERVE FORCES. CLICK TO INSPECT.</p>
        </div>
    </div>

    <script>
        /* --- PHYSICS ENGINE CONFIGURATION --- 
           Simulating identifiable representations and physical mechanisms.
        */
        const config = {
            particleRadius: 60,
            springK: 0.05,       // Spring constant (Stiffness)
            friction: 0.92,      // Damping factor
            mouseInteractionDist: 150,
            repulsion: 500
        };

        // CV Content Data - "The Identifiable Representations"
        const nodesData = [
            {
                id: 'research',
                label: 'RESEARCH',
                title: 'Fundamental AI',
                content: `
                    <p>My work focuses on <strong>provably learning physical mechanisms</strong> from raw observation.</p>
                    <p>I investigate how neural networks can recover identifiable representations of physical parameters (mass, friction, spring constants) without explicit supervision.</p>
                    <div class="math">L(θ) = || F_pred - F_gt ||² + λ || z - z* ||²</div>
                `
            },
            {
                id: 'robotics',
                label: 'ROBOTICS',
                title: 'Robot Learning',
                content: `
                    <p>Applying theoretical guarantees to real-world <strong>Bimanual Manipulation</strong>.</p>
                    <ul>
                        <li>Deformable object manipulation</li>
                        <li>Dual-arm coordination via learned dynamics</li>
                        <li>Sim-to-Real transfer of physics priors</li>
                    </ul>
                `
            },
            {
                id: 'pubs',
                label: 'PAPERS',
                title: 'Publications',
                content: `
                    <p><strong>Recent Works:</strong></p>
                    <ul>
                        <li>"Provable Identifiability of Spring-Mass Systems" (NeurIPS)</li>
                        <li>"Learning Friction Models for Dexterous Hands" (ICRA)</li>
                        <li>"Invariant Representations in Bimanual Tasks" (RSS)</li>
                    </ul>
                `
            },
            {
                id: 'contact',
                label: 'CONTACT',
                title: 'Get in Touch',
                content: `
                    <p>Interested in discussing identifiable AI or robotics?</p>
                    <p><strong>Email:</strong> name@robots.ox.ac.uk</p>
                    <p><strong>Twitter:</strong> @handle</p>
                    <p><strong>Github:</strong> github.com/handle</p>
                `
            }
        ];

        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const card = document.getElementById('info-card');
        const cardTitle = document.getElementById('card-title');
        const cardContent = document.getElementById('card-content');

        let width, height;
        let particles = [];
        let mouse = { x: 0, y: 0, isDown: false, dragging: null };

        // --- CLASSES ---

        class Particle {
            constructor(x, y, data) {
                this.pos = { x: x, y: y };
                this.vel = { x: (Math.random() - 0.5) * 2, y: (Math.random() - 0.5) * 2 };
                this.acc = { x: 0, y: 0 };
                this.mass = 10; // Arbitrary mass unit
                this.radius = config.particleRadius;
                this.data = data;
                this.hovered = false;
            }

            update() {
                // Apply friction (Damping)
                this.vel.x *= config.friction;
                this.vel.y *= config.friction;

                // Update Position
                this.pos.x += this.vel.x;
                this.pos.y += this.vel.y;

                // Wall Collisions (Bouncing)
                if (this.pos.x < this.radius) { this.pos.x = this.radius; this.vel.x *= -1; }
                if (this.pos.x > width - this.radius) { this.pos.x = width - this.radius; this.vel.x *= -1; }
                if (this.pos.y < this.radius) { this.pos.y = this.radius; this.vel.y *= -1; }
                if (this.pos.y > height - this.radius) { this.pos.y = height - this.radius; this.vel.y *= -1; }

                // Reset forces
                this.acc.x = 0;
                this.acc.y = 0;
            }

            applyForce(fx, fy) {
                this.vel.x += fx / this.mass;
                this.vel.y += fy / this.mass;
            }

            draw() {
                // Draw Connections (Springs visual)
                if (mouse.dragging === this) {
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x, this.pos.y);
                    ctx.lineTo(mouse.x, mouse.y);
                    ctx.strokeStyle = '#06b6d4'; // Cyan for spring force
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw Force Vector Text
                    ctx.fillStyle = '#06b6d4';
                    ctx.font = '10px monospace';
                    ctx.fillText('F_spring', (this.pos.x + mouse.x)/2, (this.pos.y + mouse.y)/2 - 10);
                }

                // Draw Node Body
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.hovered || mouse.dragging === this ? 'rgba(15, 23, 42, 0.9)' : 'rgba(15, 23, 42, 0.6)';
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = this.hovered || mouse.dragging === this ? '#ec4899' : '#06b6d4'; // Pink active, Cyan idle
                ctx.stroke();

                // Draw Label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Roboto Mono';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.data.label, this.pos.x, this.pos.y);

                // Draw Math Decoration (identifiability)
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.font = 'italic 10px serif';
                ctx.fillText(`z_${this.data.id}`, this.pos.x + 20, this.pos.y + 30);
            }
        }

        // --- INITIALIZATION ---

        function init() {
            resize();
            particles = [];
            
            // Spawn particles in a grid or random layout
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Position them nicely
            const positions = [
                {x: centerX - 150, y: centerY - 100},
                {x: centerX + 150, y: centerY - 100},
                {x: centerX - 150, y: centerY + 100},
                {x: centerX + 150, y: centerY + 100}
            ];

            for(let i=0; i<nodesData.length; i++) {
                particles.push(new Particle(positions[i].x, positions[i].y, nodesData[i]));
            }
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }

        // --- PHYSICS LOOP ---

        function animate() {
            ctx.clearRect(0, 0, width, height);

            // Draw Background Grid (The "Workspace")
            drawGrid();

            particles.forEach(p => {
                
                // 1. Mouse Interaction (Spring Force)
                if (mouse.dragging === p) {
                    const dx = mouse.x - p.pos.x;
                    const dy = mouse.y - p.pos.y;
                    // F = -kx
                    const fx = dx * config.springK;
                    const fy = dy * config.springK;
                    p.applyForce(fx, fy);
                }

                // 2. Inter-particle Repulsion (Prevent overlap)
                particles.forEach(other => {
                    if (other !== p) {
                        const dx = p.pos.x - other.pos.x;
                        const dy = p.pos.y - other.pos.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const minDist = p.radius + other.radius + 20;
                        
                        if (dist < minDist) {
                            const force = (minDist - dist) * 0.05;
                            const fx = (dx / dist) * force;
                            const fy = (dy / dist) * force;
                            p.applyForce(fx * 10, fy * 10);
                        }
                    }
                });

                p.update();
                p.draw();
            });

            requestAnimationFrame(animate);
        }

        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            
            // Draw Vertical Lines
            for(let x = 0; x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            
            // Draw Horizontal Lines
            for(let y = 0; y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }

        // --- EVENT LISTENERS ---

        window.addEventListener('resize', resize);

        window.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;

            // Check hover state
            let cursorStyle = 'default';
            particles.forEach(p => {
                const dx = mouse.x - p.pos.x;
                const dy = mouse.y - p.pos.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < p.radius) {
                    p.hovered = true;
                    cursorStyle = 'grab';
                } else {
                    p.hovered = false;
                }
            });
            document.body.style.cursor = mouse.dragging ? 'grabbing' : cursorStyle;
        });

        window.addEventListener('mousedown', (e) => {
            mouse.isDown = true;
            // Find clicked particle
            particles.forEach(p => {
                const dx = mouse.x - p.pos.x;
                const dy = mouse.y - p.pos.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < p.radius) {
                    mouse.dragging = p;
                    // Close card on drag start
                    card.classList.remove('active');
                }
            });
        });

        window.addEventListener('mouseup', () => {
            // Check if it was a click (minimal movement) or a drag
            if (mouse.dragging) {
                // If velocity is low, we treat it as a "Select" action
                const speed = Math.sqrt(mouse.dragging.vel.x**2 + mouse.dragging.vel.y**2);
                if (speed < 1) {
                    openCard(mouse.dragging);
                }
            }
            mouse.isDown = false;
            mouse.dragging = null;
        });

        function openCard(particle) {
            cardTitle.innerText = particle.data.title;
            cardContent.innerHTML = particle.data.content;
            card.classList.add('active');
        }

        // Close card when clicking outside
        document.addEventListener('click', (e) => {
            if(e.target.tagName === 'CANVAS' && !mouse.dragging) {
                // Check if we clicked blank space
                let clickedNode = false;
                particles.forEach(p => {
                    const dx = mouse.x - p.pos.x;
                    const dy = mouse.y - p.pos.y;
                    if(Math.sqrt(dx*dx + dy*dy) < p.radius) clickedNode = true;
                });
                
                if(!clickedNode) card.classList.remove('active');
            }
        });

        // Start
        init();
        animate();

    </script>
</body>
</html>
